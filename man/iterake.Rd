% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iterake.R
\name{iterake}
\alias{iterake}
\title{Iterative raking}
\usage{
iterake(universe, permute = FALSE, control = control_iterake())
}
\arguments{
\item{universe}{Output object created with the \code{universe()} function.}

\item{permute}{Whether to test all possible orders of categories in \code{universe}
and keep the most efficient (\code{TRUE}) or to test categories in the order listed in \code{universe}
only (default, \code{FALSE}). Setting this to \code{TRUE} will increase the run time by
a factor of the factorial of the number of weighting categories.}

\item{control}{Controls for the raking algorithm created with \code{control_iterake()}.}
}
\value{
A \code{list} that includes details of the run as well as the generated weights.
}
\description{
This function utilizes an iterative process known as Raking or RIM (Random
Iterative Method) weighting, which allows the user to adjust multiple
characteristics simultaneously without knowing the relationship between those
characteristics. This iterative fitting algorithm is rooted in the mathematical
model developed by \href{https://www.jstor.org/stable/2235722}{Deming & Stephan (1940)}.
}
\details{
The algorithm begins by assigning a temporary weight of 1 for each case. It
then calculates the weighting factor of the first group supplied in \code{universe()}
by taking the ratio of the target proportions of that weighting category to
the weighted proportions of that variable in the data. (While it is taking
a weighed proportion, it is effectively unweighted at this time since the
temporary weights are currently all set to 1).

After the weighting factors are calculated and assigned to each respondent,
the new weights are created by multiplying the existing weights by the
weighting factor. This process is repeated for each of the categories passed
to \code{universe()}.

At this point, the sum of the absolute values of the difference between the
target and actual proportions are calculated. If this value is less than the
\code{threshold} set in \code{control_iterake()}, then the algorithm has converged and
stops. Otherwise, it continues to cycle through the weighting categories until
either (a) the algorithm converges, (b) it reaches the maximum number of
iterations (set with \code{max_iter}), or (c) the algorithm gets stuck where the
sum of the absolute values of the differences osculates between getting smaller
and larger (set with \code{max_stuck}).

There are times when the usage of this weighting approach is not advisable. If
there is a known strong relationship between targets in \code{universe()}, this approach
will not capture that relationship. If there are either too large a number
of targets or targets are too discrepant from the actual sample, convergence may
not be possible - though how convergence is defined can be modified in
\code{control_iterake()}, which can make the process of converging easier or more
difficult by changing the number of iterations or the max/min weight factor
allowed.

There is also a \code{permute} argument that can be supplied to \code{iterake()}, and when set to \code{TRUE}
it will assess every order of targets in \code{universe()} possible, and select as
the winner the one that converges or has the highest effective N.
}
